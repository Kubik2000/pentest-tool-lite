import sinon from 'sinon';
import chai from 'chai';
const expect = chai.expect;
import fetch from '../../src/default/fetch.js';
import request from 'request';
import RequestCache from '../../src/request-cache';

describe('test fetch', function() {
  let sandbox;

  beforeEach(function() {
    sandbox = sinon.sandbox.create();
  });

  afterEach(function() {
    sandbox.restore();
  });

  it('should call RequestCache.request method with url and callback arguments', () => {
    sandbox.spy(RequestCache, 'request');

    fetch('https://example.com');

    sinon.assert.calledOnce(RequestCache.request);
    expect(RequestCache.request.getCalls()[0].args[0]).to.be.equal('https://example.com');
    expect(typeof RequestCache.request.getCalls()[0].args[1]).to.be.equal('function');
  });

  it('should return error, response and body', (done) => {
    sandbox.stub(request, 'get').yields({}, {headers:{ 'Content-Type': 'text/html', 'Location': 'https://otherpage.com', 'Cache-Control': 'public'}}, { something: 'something' });

    const promise = fetch('https://example3.com');

    promise.then((result) => {
      expect(result.response.hasOwnProperty('headers')).to.be.true;
      expect(result.response.headers.hasOwnProperty('content-type')).to.be.true;
      expect(result.response.headers['content-type']).to.be.equal('text/html');
      done();
    });
  });
});
