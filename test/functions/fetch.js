import sinon from 'sinon';
import chai from 'chai';
const expect = chai.expect;
import * as fetch from '../../src/functions/fetch.js';
import request from 'request';
import RequestCache from '../../src/request-cache';

describe('functions', function() {
  describe('test fetch', function() {
    let sandbox;

    beforeEach(function() {
      sandbox = sinon.sandbox.create();
      sandbox.stub(request, 'get').yields({}, {headers:{ 'Content-Type': 'text/html', 'Location': 'https://otherpage.com', 'Cache-Control': 'public'}}, { something: 'something' });
    });

    afterEach(function() {
      sandbox.restore();
      RequestCache.clearCache();
    });

    it('should call RequestCache.request method with url and callback arguments', (done) => {
      sandbox.spy(RequestCache, 'request');

      const promise = fetch.fetch('https://example.com');

      promise.then(() => {
        sinon.assert.calledOnce(RequestCache.request);
        expect(RequestCache.request.getCalls()[0].args[0]).to.be.equal('https://example.com');
        expect(typeof RequestCache.request.getCalls()[0].args[1]).to.be.equal('function');
        done();
      });
    });

    it('should return error, response and body', (done) => {
      const promise = fetch.fetch('https://example3.com');

      promise.then((result) => {
        expect(result.response.hasOwnProperty('headers')).to.be.true;
        expect(result.response.headers.hasOwnProperty('content-type')).to.be.true;
        expect(result.response.headers['content-type']).to.be.equal('text/html');
        done();
      });
    });
  });

  describe('test fetchWithoutRedirect', function() {
    let sandbox;

    beforeEach(function() {
      sandbox = sinon.sandbox.create();
      sandbox.stub(request, 'get').yields({}, {headers:{ 'Content-Type': 'text/html', 'Location': 'https://otherpage.com', 'Cache-Control': 'public'}}, { something: 'something' });
    });

    afterEach(function() {
      sandbox.restore();
      RequestCache.clearCache();
    });

    it('should call RequestCache.request method with url and callback arguments', (done) => {
      sandbox.spy(RequestCache, 'request');

      const promise = fetch.fetchWithoutRedirect('https://example4.com');

      promise.then(() => {
        sinon.assert.calledOnce(RequestCache.request);
        expect(RequestCache.request.getCalls()[0].args[0].hasOwnProperty('url')).to.be.true;
        expect(RequestCache.request.getCalls()[0].args[0].url).to.be.equal('https://example4.com');
        expect(RequestCache.request.getCalls()[0].args[0].hasOwnProperty('followRedirect')).to.be.true;
        expect(RequestCache.request.getCalls()[0].args[0].followRedirect).to.be.false;
        expect(typeof RequestCache.request.getCalls()[0].args[1]).to.be.equal('function');
        done();
      });
    });

    it('should return error, response and body', (done) => {
      const promise = fetch.fetchWithoutRedirect('https://example5.com');

      promise.then((result) => {
        expect(result.response.hasOwnProperty('headers')).to.be.true;
        expect(result.response.headers.hasOwnProperty('content-type')).to.be.true;
        expect(result.response.headers['content-type']).to.be.equal('text/html');
        done();
      });
    });
  });
});
