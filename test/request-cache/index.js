import sinon from 'sinon';
import chai from 'chai';
const expect = chai.expect;
import request from 'request';
import RequestCache from '../../src/request-cache';

describe('test request-cache', function() {
  let sandbox;

  beforeEach(function() {
    sandbox = sinon.sandbox.create();
    sandbox.stub(request, 'get').yields({}, {headers:{ 'Content-Type': 'text/html', 'Location': 'https://otherpage.com', 'Cache-Control': 'public'}}, { something: 'something' });
  });

  afterEach(function() {
    sandbox.restore();
    RequestCache.clearCache();
  });

  it('should return error, headers and body object', (done) => {
    RequestCache.request('https://example.com', function(error, response, body) {
      expect(error).to.be.an.instanceOf(Object);
      expect(response).to.an.instanceOf(Object);
      expect(body).to.be.an.instanceOf(Object);
      done();
    });
  });

  it('should make request only once', (done) => {
    RequestCache.request('https://example.com/another', function(error, response, body) {
      RequestCache.request('https://example.com/another', function(error2, response2, body2) {
        expect(request.get.calledOnce).to.be.true;
        done();
      });
    });
  });

  it('should return all headers in lowercase', (done) => {
    RequestCache.request('https://example.com', function(error, response, body) {
      expect(Object.keys(response.headers)).to.deep.equal([
        'content-type',
        'location',
        'cache-control',
      ]);
      done();
    });
  });
});
