import CSSO from 'csso';
import { getStylesheets, parseHtml } from '../functions';
import Test from '../Test';

class CSS extends Test {
  protected request: IRequest;

  protected logger: ILogger;

  constructor(request: IRequest, logger: ILogger) {
    super();
    this.request = request;
    this.logger = logger;
  }

  public async run(url: string): Promise<IResult> {
    this.logger.info('Starting CSS test...');
    const result = await this.request.get(url);
    const parsedHtml = await parseHtml(result);
    const stylesheets = getStylesheets(parsedHtml);
    const subChecks = await Promise.all(stylesheets.map(async (stylesheet) => await this.checkFile(stylesheet)));

    return this.getResult('CSS', this.getStatus(subChecks), subChecks);
  }

  protected async checkFile(file: string): Promise<IResult> {
    const filename = file.substr(file.lastIndexOf('/'));
    this.logger.debug(`Checking ${filename}...`);
    const result = await this.request.get(file);

    const isAvailable = this.isFileAvailable(result);
    const availableResult = this.getResult('Available', isAvailable ? 'SUCCESSFUL' : 'ERROR');

    if (!isAvailable) {
      return this.getResult(filename, this.getStatus([ availableResult ]), [ availableResult ]);
    }

    const cacheControl = this.isCached(result) ? 'SUCCESSFUL' : 'UNSUCCESSFUL';
    const xContentTypeOptions = this.hasXContentTypeOptionsHeader(result) ? 'SUCCESSFUL' : 'UNSUCCESSFUL';
    let minified: string;
    try {
      minified = this.isMinified(result) ? 'SUCCESSFUL' : 'UNSUCCESSFUL';
    } catch (e) {
      minified = 'ERROR';
    }

    const subChecks = [
      this.getResult('Available', 'SUCCESSFUL'),
      this.getResult('Cache-Control', cacheControl),
      this.getResult('X-Content-Type-Options', xContentTypeOptions),
      this.getResult('Minified', minified),
    ];

    return this.getResult(filename, this.getStatus(subChecks), subChecks);
  }

  protected isFileAvailable(result: any): boolean {
    if (result.response.statusCode === 404 || result.response.statusCode === 500) {
      return false;
    }
    return true;
  }

  protected isCached(result: any): boolean {
    return result.response.headers.hasOwnProperty('cache-control');
  }

  protected hasXContentTypeOptionsHeader(result: any): boolean {
    return result.response.headers.hasOwnProperty('x-content-type-options');
  }

  protected isMinified(result: any): boolean {
    const r = CSSO.minify(result.body, {restructure: false}).css;
    return r === result.body;
  }
}

export default CSS;
