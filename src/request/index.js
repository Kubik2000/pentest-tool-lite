// @flow

import request from 'request';

interface Cache {
  add(url: string, error: Object, response: Object, body: Object): void;
  has(url: string): boolean;
  get(url: string): ?Object;
  clear(): void;
}

class Request {
  cache: Cache;

  logger: Object;

  /**
   *
   * @param {Object} cache
   */
  constructor(cache: Cache, logger: Object) {
    this.cache = cache;
    this.logger = logger;
  }

  /**
   *
   * @param {string} url
   * @param {boolean} followRedirect
   * @param {function} callback
   */
  get(url: string, followRedirect: boolean): Promise<any> {
    return new Promise((resolve, reject) => {
      if (!this.cache.has(url)) {
        this.logger.verbose('Requesting' + url);
  
        request.get({ url: url, followRedirect: followRedirect }, (error, response, body) => {
          if (error !== null) {
            this.logger.error('Error during fetching data.');
            reject(error);
            return;
          }

          response.headers = this.keysToLowerCase(response.headers);
          this.cache.add(url, error, response, body);
  
          resolve({
            url: url,
            error: error,
            response: response,
            body: body,
          });
        });
      } else {
        this.logger.verbose('Returning from cache ' + url);
  
        const response = this.cache.get(url);
        resolve({
          url: url,
          error: error,
          response: response,
          body: body,
        });
      }
    });
  }



  /**
   *
   * @param {Object} obj
   * @returns {Object}
   */
  keysToLowerCase(obj: Object): Object {
    const result: Object = {};
    Object.keys(obj).forEach((key: string, value: any) => {
      result[key.toLowerCase()] = obj[key];
    });

    return result;
  }
}

export default Request;
